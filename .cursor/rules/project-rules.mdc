---
alwaysApply: true
---

# Project Rules — Dynamic Dashboard (Node.js + TS + Prisma + MySQL + React)

## Repository layout

```
/apps
  /api      # Node.js + TypeScript (Fastify), Prisma, OpenAPI
  /web      # React + TypeScript (Vite), Tailwind, Recharts, TanStack Query
/db
  /migrations
  /seed
/docs
  openapi.yaml
README.md
```

- Monorepo managed with pnpm. All scripts run from repo root.
    
- Docker Compose provides `mysql:8.x` for local dev + tests.
    

## Environments & secrets

- `.env` (local), `.env.test` (tests), `.env.example` (template).
    
- Required vars:
    
    - `DATABASE_URL=mysql://user:pass@localhost:3306/appdb`
        
    - `PORT=3000`
        
    - `WEB_ORIGIN=http://localhost:5173`
        
- Never commit real secrets. The API reads only from env (12-factor).
    

## Database (MySQL + Prisma)

- ORM: **Prisma** with explicit migrations (`prisma migrate`).
    
- Minimal schema geared for dashboarding and dynamic groupings:
    
    - `products(id, name, category_id)`
        
    - `categories(id, name)`
        
    - `customers(id, name, region)` // region is a short code
        
    - `transactions(id, product_id, customer_id, quantity, unit_price, occurred_at DATETIME)`
        
    - Derived view (optional): `v_sales_day` for pre-aggregations.
        
- Indexes: `transactions(occurred_at)`, `transactions(product_id)`, `transactions(customer_id)`, `customers(region)`.
    
- Seed data matches the front-end “model” values so the dashboard can reproduce the provided numbers exactly.
    
- Time handling: store `occurred_at` in UTC; API accepts `start`/`end` in ISO-8601 and converts to UTC.
    

## API (RESTful, dynamic charts)

- Runtime: Node 22 + **Fastify** + Zod for validation + Prisma.
    
- Base path: `/api/v1`.
    
- **Date filter is mandatory** on all chart data routes (`start`, `end`).
    
- **Endpoints**
    
    1. `GET /api/v1/charts/:type`
        
        - `:type ∈ {pie,line,bar,table}` (extendable).
            
        - Query:
            
            - `start` (ISO string, inclusive), `end` (ISO string, inclusive)
                
            - `metric` ∈ {`revenue`,`count`,`quantity`} (default `revenue`)
                
            - `groupBy` ∈ {`day`,`week`,`month`} (default `day` for line/bar)
                
            - `dimension` ∈ {`category`,`product`,`region`,`customer`} (for pie/bar)
                
            - `topN` (int, optional, for top slices/bars)
                
        - **Response shapes (library-friendly)**:
            
            - **pie**: `{ series: [{ label: string, value: number }] }`
                
            - **line**: `{ series: [{ name: string, points: [{ x: string /* ISO date */, y: number }] }] }`
                
            - **bar**: `{ categories: string[], series: [{ name: string, data: number[] }] }`
                
            - **table**: `{ columns: string[], rows: Array<Record<string, string|number>> }`
                
        - 400 if missing or invalid `start/end` or incompatible parameter combos.
            
    2. `GET /api/v1/options/:entity`
        
        - `:entity ∈ {products,categories,customers,regions}`
            
        - Query: `q` (search), `limit` (default 50), `cursor` (opaque)
            
        - **Infinite scroll** contract: return `{ items: Array<{id:string|number,label:string}>, nextCursor?: string }`
            
    3. `GET /api/v1/healthz` → `{status:"ok"}`
        
- Security/CORS: allow only `WEB_ORIGIN`; rate-limit; Helmet-equivalent headers; no PII in logs.
    
- Caching: ETag on chart responses for identical queries; 60s default unless `Cache-Control: no-store` present.
    

## Validation & errors

- All inputs validated with Zod; parse failures return RFC7807 problem+json:
    
    ```
    { "type": "https://docs/errors/validation", "title": "Invalid request",
      "status": 400, "detail": "..." }
    ```
    
- Consistent error envelope for 4xx/5xx.
    

## Documentation

- Maintain `/docs/openapi.yaml` as the single source of truth.
    
- Serve Swagger UI at `/api/docs` in dev.
    
- Every endpoint includes: summary, params, sample requests, response examples, and status codes (200, 400, 401, 404, 429, 500).
    

## Testing (unit + integration)

- Test runner: **Vitest**. HTTP tests via **Supertest**.
    
- Integration uses **testcontainers** (MySQL). Migrate + seed before test runs.
    
- Coverage goals for this test: overall ≥80%, routes/services ≥90%.
    
- Test layout:
    

```
/apps/api/tests
  unit/
  integration/
```

- Unit: services, mappers, validators (no DB).
    
- Integration: route contracts, filtering, pagination, topN, error paths.
    

## Frontend (dashboard)

- Stack: **React + TypeScript + Vite**, Tailwind, **Recharts**, **TanStack Query**.
    
- Pages/components:
    
    - `DashboardPage` renders panels for pie/line/bar/table and controls.
        
    - Controls: date range picker (required), metric select, dimension select, groupBy select, topN input.
        
    - **Selects** use **infinite scroll** bound to `/api/v1/options/:entity` with intersection observer.
        
- Data fetching:
    
    - Query keys include all params (`['chart', type, start, end, metric, groupBy, dimension, topN]`).
        
    - Map API shapes 1:1 to Recharts without re-shaping beyond trivial renames.
        
- Accessibility: semantic elements, labeled inputs, keyboard nav, focus outlines.
    

## Build & scripts (pnpm)

At repo root:

```
pnpm i
pnpm -w run dev         # runs api (3000) and web (5173)
pnpm -w run db:up       # docker compose up -d mysql
pnpm -w run db:migrate
pnpm -w run db:seed
pnpm -w run test
pnpm -w run lint && pnpm -w run typecheck
```

`/apps/api/package.json` (key scripts):

- `dev`, `build`, `start`, `test`, `test:integration`, `swagger`, `migrate`, `seed`.
    

`/apps/web/package.json`:

- `dev`, `build`, `preview`, `typecheck`, `lint`, `test`.
    

## CI (lightweight for the test)

- On PR: typecheck → lint → unit → integration (with MySQL service) → coverage gate.
    
- On main: build API + Web; emit OpenAPI artifact; run smoke E2E (optional).
    

## Definition of Done (for this challenge)

- Backend:
    
    - Prisma schema + migrations + seed present and reproducible.
        
    - All chart routes implemented with strict validation and mandatory date filters.
        
    - Options endpoints support **cursor pagination** and `q` search (for infinite scroll).
        
    - OpenAPI docs complete; `/api/docs` functional in dev.
        
    - Unit + integration tests meet coverage targets; README shows curl examples.
        
- Frontend:
    
    - Dashboard replicates layout and **exact values** from the provided model (via seed).
        
    - Infinite scroll in selects works smoothly; no full-list fetches.
        
    - Error states, loading skeletons, and empty states handled.
        
- Repo:
    
    - `README.md` explains setup, env, run/test commands, and how to reproduce screenshots.
        

## Conventions & naming

- Files: kebab-case; TS types in `*.types.ts`; Zod schemas in `*.schema.ts`.
    
- Services: pure, stateless where possible (`/apps/api/src/services`).
    
- Controllers: thin; validation at boundary; no ORM leakage to UI.
    
- Commits: conventional commits; small, focused changes.
    

## Grading guardrails (what to optimize for)

- **Correctness & clarity** first: readable queries, explicit groupings, clear mapping to chart shapes.
    
- **Robustness**: required date filters; good errors; tested pagination and edge cases.
    
- **Docs**: endpoint shapes are obvious, with examples copy-pastable into curl or the web app’s fetch layer.